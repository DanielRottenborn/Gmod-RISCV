@name RiscV-64I
@model models/bull/gates/processor.mdl
@persist [IntRegisters]:array
@persist [Initialized]:number
@persist [Memory]:table
@persist [PC]:vector2
@strict

interval(1000)

const UINT32OVF = 2 ^ 32  # MaxUInt32 + 1


function printVec2InHex(Value:vector2) {  # Prints unsigned vector2 components in hex
    print(format("%X|%X", Value:x(), Value:y()))
}

function number toUnsigned(Value:number) {  # Signed int32 to unsigned int32 conversion (in lua fp number representation)
    return Value % UINT32OVF
}

function number number:getFlag(Index:number) {
    return (This >> Index) && 0x1
}

function number getFunct3(InstrByte3:number) {
    return (InstrByte3 >> 4) && 0x7
}

function number getRd(InstrByte3:number, InstrByte4:number) {  # Returns destination register
    return ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)     
}

function number getRs1(InstrByte2:number, InstrByte3:number) {  # Returns first source register
    return ((InstrByte2 && 0xF) << 1) + (InstrByte3 >> 7)    
}

function number getRs2(InstrByte1:number, InstrByte2:number) {  # Returns second source register
    return ((InstrByte1 && 0x1) << 4) + (InstrByte2 >> 4)
}

function number getIImm(InstrByte1:number, InstrByte2:number) {  # Returns I-type immediate value
    return (InstrByte1 << 4) + (InstrByte2 >> 4)
}

function number getUImm(InstrByte1:number, InstrByte2:number, InstrByte3:number) {  # Returns U-type immediate value
    let Imm = (InstrByte1 << 12) + (InstrByte2 << 4) + (InstrByte3 >> 4)  # 20-bit immediate value
    return toUnsigned(Imm << 12)  # Upper immediate value
}

function vector2 number:signExt32to64() {  # Sign-extends 32-bit value to 64 bits
    let Sign = This >> 31
    return vec2(0xFFFFFFFF * Sign, This) 
}

function vector2 number:signExt12to64() {  # Sign-extends 12-bit value to 64 bits
    let Sign = This >> 11
    return vec2(0xFFFFFFFF, 0xFFFFF000) * Sign + vec2(0, This)   
}

function number number:signExt12to32() {  # Sign-extends 12-bit value to 32 bits
    let Sign = This >> 11
    return 0xFFFFF000 * Sign + This  
}

function vector2 bAnd64(Value1:vector2, Value2:vector2) {
    return vec2(toUnsigned(bAnd(Value1:x(), Value2:x())), toUnsigned(bAnd(Value1:y(), Value2:y()))) 
}

function vector2 bOr64(Value1:vector2, Value2:vector2) {
    return vec2(toUnsigned(bOr(Value1:x(), Value2:x())), toUnsigned(bOr(Value1:y(), Value2:y()))) 
}

function vector2 bXor64(Value1:vector2, Value2:vector2) {
    return vec2(toUnsigned(bXor(Value1:x(), Value2:x())), toUnsigned(bXor(Value1:y(), Value2:y()))) 
}

function vector2 vector2:addInt64(Value:vector2) {
    let LowerSum = This:y() + Value:y()
    return mod(vec2(This:x() + Value:x() + (LowerSum >= UINT32OVF), LowerSum), UINT32OVF)
}

function vector2 vector2:addInt32(Value:number) {
    let LowerSum = This:y() + Value
    return mod(vec2(This:x() + (LowerSum >= UINT32OVF), LowerSum), UINT32OVF)
}

function vector2 vector2:subInt64(Value:vector2) {
    let LowerDiff = This:y() - Value:y()
    return vec2((This:x() - Value:x() - (LowerDiff < 0)) % UINT32OVF, LowerDiff % UINT32OVF) 
}

function vector2 vector2:isLessThanU(Value:vector2) {  # Compares two 64-bit integers in unsigned interpretation
    if (This:x() == Value:x()) {
        return vec2(0, This:y() < Value:y())
        
    } else {
        return vec2(0, This:x() < Value:x())
    }
}

function vector2 vector2:isLessThan(Value:vector2) {  # Compares two 64-bit integers in signed interpretation
    This = This:setX(toUnsigned(bXor(This:x(), 0x80000000)))  # Swapping the sign bits for signed comparison
    Value = Value:setX(toUnsigned(bXor(Value:x(), 0x80000000)))

    return This:isLessThanU(Value)
}

function vector2 vector2:int64ShiftLeftLogical(ShiftAmount:number) {  # Max shift amount is 63
    if (ShiftAmount >= 32) {
        return vec2(toUnsigned(This:y() << (ShiftAmount - 32)), 0)
        
    } elseif (ShiftAmount >= 1) {
        return vec2(toUnsigned(This:x() << ShiftAmount) + (This:y() >> (32 - ShiftAmount)), toUnsigned(This:y() << ShiftAmount))
        
    } else { return This }
}

function vector2 vector2:int64ShiftRightLogical(ShiftAmount:number) {  # Max shift amount is 63
    if (ShiftAmount >= 33) {
        return vec2(0, This:x() >> (ShiftAmount - 32))
        
    } elseif (ShiftAmount == 32) {
        return vec2(0, This:x())
        
    } elseif (ShiftAmount >= 1) {
        return vec2(This:x() >> ShiftAmount, (This:y() >> ShiftAmount) + toUnsigned(This:x() << (32 - ShiftAmount)))
        
    } else { return This }
}

function vector2 vector2:int64ShiftRightArithmetic(ShiftAmount:number) {  # Max shift amount is 63
    let Sign = This:x() >> 31  # Sign of the value to be shifted
    
    if (Sign) {
        This = vec2(bNot(This:x()), bNot(This:y()))  # Flip bits if the value is negative
        This = This:int64ShiftRightLogical(ShiftAmount)
        
        return vec2(toUnsigned(bNot(This:x())), toUnsigned(bNot(This:y())))  # Flip bits back
        
    } else { return This:int64ShiftRightLogical(ShiftAmount) }
}

function vector2 vector2:int64ShiftRightArithmetic_DEPRECATED(ShiftAmount:number) {  # Shifting & calculating extension bits manualy
    let Sign = This:x() >> 31  # Sign of the value to be shifted
    
    if (ShiftAmount >= 33) {
        let SignExtension = toUnsigned((2 ^ (ShiftAmount - 32) - 1) << (64 - ShiftAmount)) * Sign
        return vec2(0xFFFFFFFF * Sign, (This:x() >> (ShiftAmount - 32)) + SignExtension)
        
    } elseif (ShiftAmount == 32) {
        return vec2(0xFFFFFFFF * Sign, This:x())
        
    } elseif (ShiftAmount >= 1) {
        let SignExtension = toUnsigned((2 ^ ShiftAmount - 1) << (32 - ShiftAmount)) * Sign
        return vec2((This:x() >> ShiftAmount) + SignExtension, (This:y() >> ShiftAmount) + toUnsigned(This:x() << (32 - ShiftAmount)))
        
    } else { return This }
}

function number number:int32ShiftRightArithmetic(ShiftAmount:number) {  # Max shift amount is 31
    let Sign = This >> 31  # Sign of the value to be shifted
    
    if (Sign) {
        This = bNot(This)  # Flip bits if the value is negative
        This = This >> ShiftAmount
        
        return toUnsigned(bNot(This))  # Flip bits back
        
    } else { return toUnsigned(This >> ShiftAmount) }
}

if (first() | dupefinished()) {
    # 64-bit registers are stored in vector2 form, x component contains upper 32 bits, y component contains lower 32 bits
    
    IntRegisters = array(  # 32 (x0-x31) 64-bit integer registers
        1 = vec2(0x0, 0x0),
        2 = vec2(0x0, 00)
    )
    
    PC = vec2()  # Program counter register
      
    Memory = table()  # 64-bit memory addressable in "[upper_uint32,lower_uint32]" format
    
    let Instruction = 0x4020D1BB  # for testing purposes
    Memory["[0,0]", number] = Instruction && 0xFF
    Memory["[0,1]", number] = (Instruction >> 8) && 0xFF    
    Memory["[0,2]", number] = (Instruction >> 16) && 0xFF 
    Memory["[0,3]", number] = (Instruction >> 24) 
        
    Initialized = 1
    
    
} elseif (Initialized) {
    let InstrByte1 = _INF
    let InstrByte2 = _INF
    let InstrByte3 = _INF
    let InstrByte4 = _INF
    
    if (PC:y() + 3 >= UINT32OVF) {  # If PC is close to overflowing, do propper addition
        InstrByte1 = Memory[PC:addInt32(3):toString(), number]
        InstrByte2 = Memory[PC:addInt32(2):toString(), number]
        InstrByte3 = Memory[PC:addInt32(1):toString(), number]
        InstrByte4 = Memory[PC:toString(), number]
        
    } else {  # Do simplified addition otherwise
        InstrByte1 = Memory[PC:setY(PC:y() + 3):toString(), number]
        InstrByte2 = Memory[PC:setY(PC:y() + 2):toString(), number]
        InstrByte3 = Memory[PC:setY(PC:y() + 1):toString(), number]
        InstrByte4 = Memory[PC:toString(), number]
    }
    
    
    let Opcode = InstrByte4 && 0x7F
    
    if (Opcode == 0b0010011) {  # OP-IMM instructions  
        let Funct = getFunct3(InstrByte3)
        
        let Rs = getRs1(InstrByte2, InstrByte3)  # Source register
        let RsValue = IntRegisters[Rs, vector2]
        
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register
        
        let Imm = getIImm(InstrByte1, InstrByte2)  # 12-bit immediate value
        let SExtImm = Imm:signExt12to64()  # Sign-extended immediate value
         
        if (Funct == 0b000) {  # ADDI instruction
            IntRegisters[Rd, vector2] = RsValue:addInt64(SExtImm)
            
        } elseif (Funct == 0b010) {  # SLTI instruction
            IntRegisters[Rd, vector2] = RsValue:isLessThan(SExtImm)
            
        } elseif (Funct == 0b011) {  # SLTIU instruction
            IntRegisters[Rd, vector2] = RsValue:isLessThanU(SExtImm)
            
        } elseif (Funct == 0b111) {  # ANDI instruction
            IntRegisters[Rd, vector2] = bAnd64(RsValue, SExtImm)
            
        } elseif (Funct == 0b110) {  # ORI instruction
            IntRegisters[Rd, vector2] = bOr64(RsValue, SExtImm)
            
        } elseif (Funct == 0b100) {  # XORI instruction
            IntRegisters[Rd, vector2] = bXor64(RsValue, SExtImm)
            
        } elseif (Funct == 0b001) {  # SLLI instruction
            let Shamt = SExtImm:y() && 0x3F  # Shift amount
            IntRegisters[Rd, vector2] = RsValue:int64ShiftLeftLogical(Shamt)
            
        } elseif (Funct == 0b101) {  # SRLI & SRAI instructions
            let ShiftType = InstrByte1:getFlag(6)
            let Shamt = SExtImm:y() && 0x3F  # Shift amount

            if (ShiftType == 0) {  # SRLI instruction
                IntRegisters[Rd, vector2] = RsValue:int64ShiftRightLogical(Shamt)
                
            } else {  # SRAI instruction
                IntRegisters[Rd, vector2] = RsValue:int64ShiftRightArithmetic(Shamt)
            }
        }
        
            
    } elseif (Opcode == 0b0011011) {  # OP-IMM-32 instructions
        let Funct = getFunct3(InstrByte3)
              
        let Rs = getRs1(InstrByte2, InstrByte3)  # Source register
        let LowerRsValue = IntRegisters[Rs, vector2]:y()
        
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register
        
        let Imm = getIImm(InstrByte1, InstrByte2)  # Immediate value        
        
        let Result = _INF
        
        if (Funct == 0b000) {  # ADDIW instruction
            let SExtImm = Imm:signExt12to32()  # Sign-extended lower immediate value
            
            Result = (LowerRsValue + SExtImm) % UINT32OVF
                     
        } elseif (Funct == 0b001) {  # SLLIW instruction
            let Shamt = Imm && 0x1F  # Shift amount
            
            Result = toUnsigned(LowerRsValue << Shamt)
            
        } elseif (Funct == 0b101) {  # SRLIW & SRAIW instructions
            let ShiftType = InstrByte1:getFlag(6) 
            let Shamt = Imm && 0x1F  # Shift amount
            
            if (ShiftType == 0) {  # SRLIW instruction
                Result = toUnsigned(LowerRsValue >> Shamt)
                
            } else {  # SRAIW instruction
                Result = LowerRsValue:int32ShiftRightArithmetic(Shamt)   
            }       
        }
        
        IntRegisters[Rd, vector2] = Result:signExt32to64()

   
    } elseif (Opcode == 0b0110111) {  # LUI instruction
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register        
        let Imm = getUImm(InstrByte1, InstrByte2, InstrByte3)  # Upper immediate value
  
        IntRegisters[Rd, vector2] = Imm:signExt32to64()
        
        
    } elseif (Opcode == 0b0010111) {  # AUIPC instruction
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register
        let Imm = getUImm(InstrByte1, InstrByte2, InstrByte3)  # Upper immediate value

        IntRegisters[Rd, vector2] = PC:addInt64(Imm:signExt32to64()) 
        
        
    } elseif (Opcode == 0b0110011) {  # OP instructions
        let Funct = getFunct3(InstrByte3)
        
        let Rs1 = getRs1(InstrByte2, InstrByte3)  # First source register
        let Rs1Value = IntRegisters[Rs1, vector2]

        let Rs2 = getRs2(InstrByte1, InstrByte2)  # Second source register
        let Rs2Value = IntRegisters[Rs2, vector2]
        
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register
        
        if (Funct == 0b000) {  # ADD & SUB instructions
            let OpType = InstrByte1:getFlag(6)
            
            if (OpType == 0) {  # ADD instruction
                IntRegisters[Rd, vector2] = Rs1Value:addInt64(Rs2Value)
           
            } else {  # SUB instruction
                IntRegisters[Rd, vector2] = Rs1Value:subInt64(Rs2Value)
            }
            
        } elseif (Funct == 0b010) {  # SLT instruction
            IntRegisters[Rd, vector2] = Rs1Value:isLessThan(Rs2Value)
              
        } elseif (Funct == 0b011) {  # SLTU instruction
            IntRegisters[Rd, vector2] = Rs1Value:isLessThanU(Rs2Value)
              
        } elseif (Funct == 0b111) {  # AND instruction
            IntRegisters[Rd, vector2] = bAnd64(Rs1Value, Rs2Value)
            
        } elseif (Funct == 0b110) {  # OR instruction
            IntRegisters[Rd, vector2] = bOr64(Rs1Value, Rs2Value)
           
        } elseif (Funct == 0b100) {  # XOR instruction
            IntRegisters[Rd, vector2] = bXor64(Rs1Value, Rs2Value)
           
        } elseif (Funct == 0b001) {  # SLL instruction
            let Shamt = Rs2Value:y() && 0x3F  # Shift amount
            IntRegisters[Rd, vector2] = Rs1Value:int64ShiftLeftLogical(Shamt)

        } elseif (Funct == 0b101) {  # SRL & SRA instructions
            let ShiftType = InstrByte1:getFlag(6)
            let Shamt = Rs2Value:y() && 0x3F  # Shift amount
          
            if (ShiftType == 0) {  # SRL instruction
                IntRegisters[Rd, vector2] = Rs1Value:int64ShiftRightLogical(Shamt)
                 
            } else {  # SRA instruction
                IntRegisters[Rd, vector2] = Rs1Value:int64ShiftRightArithmetic(Shamt)                    
            } 
        }
        
        
    } elseif (Opcode == 0b0111011) {  # OP-32 instructions
        let Funct = getFunct3(InstrByte3)
        
        let Rs1 = getRs1(InstrByte2, InstrByte3)  # First source register
        let LowerRs1Value = IntRegisters[Rs1, vector2]:y()

        let Rs2 = getRs2(InstrByte1, InstrByte2)  # Second source register
        let LowerRs2Value = IntRegisters[Rs2, vector2]:y()
        
        let Rd = getRd(InstrByte3, InstrByte4)  # Destination register       
        
        let Result = _INF
        
        if (Funct == 0b000) {  # ADDW & SUBW instructions
            let OpType = InstrByte1:getFlag(6)
            
            if (OpType == 0) {  # ADDW instruction
                Result = (LowerRs1Value + LowerRs2Value) % UINT32OVF
           
            } else {  # SUBW instruction
                Result = (LowerRs1Value - LowerRs2Value) % UINT32OVF
            } 
                           
        } elseif (Funct == 0b001) {  # SLLW instruction
            let Shamt = LowerRs2Value && 0x1F  # Shift amount

            Result = toUnsigned(LowerRs1Value << Shamt)
            
        } elseif (Funct == 0b101) {  # SRLW & SRAW instructions
            let ShiftType = InstrByte1:getFlag(6) 
            let Shamt = LowerRs2Value && 0x1F  # Shift amount
            
            if (ShiftType == 0) {  # SRLW instruction
                Result = toUnsigned(LowerRs1Value >> Shamt)
                
            } else {  # SRAW instruction
                Result = LowerRs1Value:int32ShiftRightArithmetic(Shamt)   
            }                   
        }
        
        IntRegisters[Rd, vector2] = Result:signExt32to64()           
    }
}
