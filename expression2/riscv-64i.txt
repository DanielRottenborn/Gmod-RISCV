@name RiscV-64I
@model models/bull/gates/processor.mdl
@persist [IntRegisters]:array
@persist [Initialized]:number
@persist [Memory]:table
@persist [PC]:vector2
@strict

interval(1000)

const UINT32OVF = 2 ^ 32  # MaxUInt32 + 1


function printVec2InHex(Value:vector2) {  # Prints unsigned vector2 components in hex
    print(format("%X|%X", Value:x(), Value:y()))
}

function number s2u_32(Number:number) {  # Signed int32 to unsigned int32 conversion (in lua fp number representation)
    return Number % UINT32OVF
}

function vector2 vector2:addInt64(Value:vector2) {
    let LowerSum = This:y() + Value:y()
    return mod(vec2(This:x() + Value:x() + (LowerSum >= UINT32OVF), LowerSum), UINT32OVF)
}

function vector2 vector2:addInt32(Value:number) {
    let LowerSum = This:y() + Value
    return mod(vec2(This:x() + (LowerSum >= UINT32OVF), LowerSum), UINT32OVF)
}

function vector2 vector2:subInt64(Value:vector2) {
    let LowerDiff = This:y() - Value:y()
    return vec2((This:x() - Value:x() - (LowerDiff < 0)) % UINT32OVF, LowerDiff % UINT32OVF) 
}

function vector2 vector2:isLessThanU(Value:vector2) {  # Compares two 64 bit integers in unsigned interpretation
    if (This:x() == Value:x()) {
        return vec2(0, This:y() < Value:y())
        
    } else {
        return vec2(0, This:x() < Value:x())
    }
}

function vector2 vector2:isLessThan(Value:vector2) {  # Compares two 64 bit integers in signed interpretation
    This = This:setX((This:x() + 2 ^ 31) % UINT32OVF)  # Swapping the sign bit for signed comparison
    Value = Value:setX((Value:x() + 2 ^ 31) % UINT32OVF)
    
    return This:isLessThanU(Value)
}

function vector2 vector2:int64ShiftLeftLogical(ShiftAmount:number) {  # Maximum shift amount is 63
    if (ShiftAmount > 31) {
        return vec2(s2u_32(This:y() << (ShiftAmount - 32)), 0)
        
    } elseif (ShiftAmount > 0) {
        return vec2(s2u_32(This:x() << ShiftAmount) + (This:y() >> (32 - ShiftAmount)), s2u_32(This:y() << ShiftAmount))
        
    } else { return This }
}

function vector2 vector2:int64ShiftRightLogical(ShiftAmount:number) {  # Maximum shift amount is 63
    if (ShiftAmount > 32) {
        return vec2(0, This:x() >> (ShiftAmount - 32))
        
    } elseif (ShiftAmount > 31) {
        return vec2(0, This:x())
        
    } elseif (ShiftAmount > 0) {
        return vec2(This:x() >> ShiftAmount, (This:y() >> ShiftAmount) + s2u_32(This:x() << (32 - ShiftAmount)))
        
    } else { return This }
}

function vector2 vector2:int64ShiftRightArithmetic(ShiftAmount:number) {  # Maximum shift amount is 63
    let ValueSign = This:x() >> 31
    
    if (ValueSign) {
        This = vec2(bNot(This:x()), bNot(This:y()))  # Flip bits if the value is negative
        This = This:int64ShiftRightLogical(ShiftAmount)
        
        return vec2(s2u_32(bNot(This:x())), s2u_32(bNot(This:y())))  # Flip bits back
        
    } else { return This:int64ShiftRightLogical(ShiftAmount) }
}

function vector2 vector2:int64ShiftRightArithmetic_DEPRECATED(ShiftAmount:number) {  # Shifting & calculating extension bits manualy
    let ValueSign = This:x() >> 31  # <---
    
    if (ShiftAmount > 32) {
        let SignExtension = s2u_32((2 ^ (ShiftAmount - 32) - 1) << (64 - ShiftAmount)) * ValueSign  # <---
        return vec2(0xFFFFFFFF * ValueSign, (This:x() >> (ShiftAmount - 32)) + SignExtension)  # <---
        
    } elseif (ShiftAmount > 31) {
        return vec2(0xFFFFFFFF * ValueSign, This:x())  # <---
        
    } elseif (ShiftAmount > 0) {
        let SignExtension = s2u_32((2 ^ ShiftAmount - 1) << (32 - ShiftAmount)) * ValueSign  # <---
        return vec2((This:x() >> ShiftAmount) + SignExtension, (This:y() >> ShiftAmount) + s2u_32(This:x() << (32 - ShiftAmount)))  # <---
        
    } else { return This }
}

function number number:int32ShiftRightArithmetic(ShiftAmount:number) {  # Maximum shift amount is 31
    let ValueSign = This >> 31
    
    if (ValueSign) {
        This = bNot(This)  # Flip bits if the value is negative
        This = This >> ShiftAmount
        
        return s2u_32(bNot(This))  # Flip bits back
        
    } else { return s2u_32(This >> ShiftAmount) }
}

if (first() | dupefinished()) {
    # 64 bit registers are stored in vector2 form, x component contains upper 32 bits, y component contains lower 32 bits
    
    IntRegisters = array(1 = vec2(0x0, 0x0), 2 = vec2(0xFFFFFFFF, 0xFFFFFFFF))  # 32 (x0-x31) 64 bit integer registers
    PC = vec2()  # Program counter register
      
    Memory = table()  # 64 bit memory addressable in "[upper_uint32,lower_uint32]" format
    
    let Instruction = 0x402081B3  # for testing purposes
    Memory["[0,0]", number] = Instruction && 0xFF
    Memory["[0,1]", number] = (Instruction >> 8) && 0xFF    
    Memory["[0,2]", number] = (Instruction >> 16) && 0xFF 
    Memory["[0,3]", number] = (Instruction >> 24) 
        
    Initialized = 1
    
    
} elseif (Initialized) {
    let InstrByte1 = _INF
    let InstrByte2 = _INF
    let InstrByte3 = _INF
    let InstrByte4 = _INF
    
    if (PC:y() + 3 >= UINT32OVF) {  # If PC is close to overflowing, do propper addition
        InstrByte1 = Memory[PC:addInt32(3):toString(), number]
        InstrByte2 = Memory[PC:addInt32(2):toString(), number]
        InstrByte3 = Memory[PC:addInt32(1):toString(), number]
        InstrByte4 = Memory[PC:toString(), number]
        
    } else {  # Do simplified addition otherwise
        InstrByte1 = Memory[PC:setY(PC:y() + 3):toString(), number]
        InstrByte2 = Memory[PC:setY(PC:y() + 2):toString(), number]
        InstrByte3 = Memory[PC:setY(PC:y() + 1):toString(), number]
        InstrByte4 = Memory[PC:toString(), number]
    }
    
    
    let Opcode = InstrByte4 && 0x7F
    
    if (Opcode == 0b0010011) {  # OP-IMM instructions
        let Funct = (InstrByte3 >> 4) && 0x7
        
        let Rs = ((InstrByte2 && 0xF) << 1) + (InstrByte3 >> 7)  # Source register
        let RsValue = IntRegisters[Rs, vector2]
        
        let Rd = ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)  # Destination register
        
        let Imm = (InstrByte1 << 4) + (InstrByte2 >> 4)  # Immediate value
        
        let ImmSign = Imm >> 11  # Immediate value sign  # <---
        let SE_Imm = vec2(0xFFFFFFFF, 0xFFFFF000) * ImmSign + vec2(0, Imm)  # Sign-extended immediate value  # <---
        
        
        if (Funct == 0b000) {  # ADDI instruction
            IntRegisters[Rd, vector2] = RsValue:addInt64(SE_Imm)
            
        } elseif (Funct == 0b010) {  # SLTI instruction
            IntRegisters[Rd, vector2] = RsValue:isLessThan(SE_Imm)
            
        } elseif (Funct == 0b011) {  # SLTIU instruction
            IntRegisters[Rd, vector2] = RsValue:isLessThanU(SE_Imm)
            
        } elseif (Funct == 0b111) {  # ANDI instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bAnd(RsValue:x(), SE_Imm:x())), s2u_32(bAnd(RsValue:y(), SE_Imm:y())))
            
        } elseif (Funct == 0b110) {  # ORI instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bOr(RsValue:x(), SE_Imm:x())), s2u_32(bOr(RsValue:y(), SE_Imm:y())))
            
        } elseif (Funct == 0b100) {  # XORI instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bXor(RsValue:x(), SE_Imm:x())), s2u_32(bXor(RsValue:y(), SE_Imm:y())))
            
        } elseif (Funct == 0b001) {  # SLLI instruction
            let Shamt = Imm && 0x3F  # Shift amount
            IntRegisters[Rd, vector2] = RsValue:int64ShiftLeftLogical(Shamt)
            
        } elseif (Funct == 0b101) {  # SRLI & SRAI instructions
            let ShiftType = (Imm >> 10) && 0x1
            let Shamt = Imm && 0x3F  # Shift amount

            if (ShiftType == 0) {  # SRLI instruction
                IntRegisters[Rd, vector2] = RsValue:int64ShiftRightLogical(Shamt)
                
            } else {  # SRAI instruction
                IntRegisters[Rd, vector2] = RsValue:int64ShiftRightArithmetic(Shamt)
            }
        }
        
        
    } elseif (Opcode == 0b0011011) {  # OP-IMM-32 instructions
        let Funct = (InstrByte3 >> 4) && 0x7  
              
        let Rs = ((InstrByte2 && 0xF) << 1) + (InstrByte3 >> 7)  # Source register
        let LowerRsValue = IntRegisters[Rs, vector2]:y()
        
        let Rd = ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)  # Destination register
        
        let Imm = (InstrByte1 << 4) + (InstrByte2 >> 4)  # Immediate value        
        
        let Result = _INF
        
        if (Funct == 0b000) {  # ADDIW instruction
            let ImmSign = Imm >> 11  # Immediate value sign  # <---
            let SE_Imm = 0xFFFFF000 * ImmSign + Imm  # Sign-extended lower immediate value  # <---
            
            Result = (LowerRsValue + SE_Imm) % UINT32OVF
                     
        } elseif (Funct == 0b001) {  # SLLIW instruction
            let Shamt = Imm && 0x1F  # Shift amount
            
            Result = s2u_32(LowerRsValue << Shamt)
            
        } elseif (Funct == 0b101) {  # SRLIW & SRAIW instructions
            let ShiftType = (Imm >> 10) && 0x1 
            let Shamt = Imm && 0x1F  # Shift amount
            
            if (ShiftType == 0) {  # SRLIW instruction
                Result = s2u_32(LowerRsValue >> Shamt)
                
            } else {  # SRAIW instruction
                Result = LowerRsValue:int32ShiftRightArithmetic(Shamt)   
            }       
        }
        
        let ResultSign = Result >> 31  # <---
        IntRegisters[Rd, vector2] = vec2(0xFFFFFFFF * ResultSign, Result)  # <--- 

          
    } elseif (Opcode == 0b0110111) {  # LUI instruction
        let Rd = ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)  # Destination register
        
        let Imm = (InstrByte1 << 12) + (InstrByte2 << 4) + (InstrByte3 >> 4)  # Immediate value
        let ImmSign = InstrByte1 >> 7
        
        let UpperImm = vec2(0xFFFFFFFF * ImmSign, s2u_32(Imm << 12))  # Upper mmediate value  # <---
        
        IntRegisters[Rd, vector2] = UpperImm
        
        
    } elseif (Opcode == 0b0010111) {  # AUIPC instruction
        let Rd = ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)  # Destination register
        
        let Imm = (InstrByte1 << 12) + (InstrByte2 << 4) + (InstrByte3 >> 4)  # Immediate value
        let ImmSign = InstrByte1 >> 7
        
        let UpperImm = vec2(0xFFFFFFFF * ImmSign, s2u_32(Imm << 12))  # Upper mmediate value  # <---

        IntRegisters[Rd, vector2] = PC:addInt64(UpperImm) 
        
    } elseif (Opcode == 0b0110011) {  # OP instructions
        let Funct = (InstrByte3 >> 4) && 0x7
        
        let Rs1 = ((InstrByte2 && 0xF) << 1) + (InstrByte3 >> 7)  # First source register
        let Rs1Value = IntRegisters[Rs1, vector2]

        let Rs2 = ((InstrByte1 && 0x1) << 4) + (InstrByte2 >> 4)  # Second source register
        let Rs2Value = IntRegisters[Rs2, vector2]
        
        let Rd = ((InstrByte3 && 0xF) << 1) + (InstrByte4 >> 7)  # Destination register
        
        if (Funct == 0b000) {  # ADD & SUB instructions
            let InstrType = (InstrByte1 >> 6) && 0x1  # 6th byte flag from funct7
            
            if (InstrType == 0) {  # ADD instruction
                IntRegisters[Rd, vector2] = Rs1Value:addInt64(Rs2Value)
           
            } elseif (InstrType == 1) {  # SUB instruction
                IntRegisters[Rd, vector2] = Rs1Value:subInt64(Rs2Value)
            }
            
        } elseif (Funct == 0b010) {  # SLT instruction
            IntRegisters[Rd, vector2] = Rs1Value:isLessThan(Rs2Value)
              
        } elseif (Funct == 0b011) {  # SLTU instruction
            IntRegisters[Rd, vector2] = Rs1Value:isLessThanU(Rs2Value)
              
        } elseif (Funct == 0b111) {  # AND instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bAnd(Rs1Value:x(), Rs2Value:x())), s2u_32(bAnd(Rs1Value:y(), Rs2Value:y())))
           
        } elseif (Funct == 0b110) {  # OR instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bOr(Rs1Value:x(), Rs2Value:x())), s2u_32(bOr(Rs1Value:y(), Rs2Value:y())))
           
        } elseif (Funct == 0b100) {  # XOR instruction
            IntRegisters[Rd, vector2] = vec2(s2u_32(bXor(Rs1Value:x(), Rs2Value:x())), s2u_32(bXor(Rs1Value:y(), Rs2Value:y())))
           
        } elseif (Funct == 0b001) {  # SLL instruction
            let Shamt = Rs2Value:y() && 0x3F  # Shift amount
            IntRegisters[Rd, vector2] = Rs1Value:int64ShiftLeftLogical(Shamt)

        } elseif (Funct == 0b101) {  # SRL & SRA instructions
            let InstrType = (InstrByte1 >> 6) && 0x1  # 6th byte flag from funct7 
            let Shamt = Rs2Value:y() && 0x3F  # Shift amount
          
            if (InstrType == 0) {  # SRL instruction
                IntRegisters[Rd, vector2] = Rs1Value:int64ShiftRightLogical(Shamt)
                 
            } else {  # SRA instruction
                IntRegisters[Rd, vector2] = Rs1Value:int64ShiftRightArithmetic(Shamt)                    
            } 
        }
    }
}

#[

GENERAL INFORMATION:

    XLEN - The width of an int register
    
    Addressible memory - 2^XLEN bytes
    Memory is circular
    Word - 4bytes
    
    IALIGN - Allignment boundary for instructions, either 32 bits or 16 bits (for C extension)
    ILEN - Maximum supported instruction length (32 bits in standard set)
    32 bit instructions have two lowest bits set to 11, compressed instructions do not
    Instructions with bits [15:0] all zeros are illegal, the length is considered 16 bits if C extension is present, otherwise, 32 bits
    Instructions with bits [ILEN - 1:0] all ones are illegal, the length is considered ILEN bits long
    Instrucions are always stored in a little-endian format
    
    
    IMPORTANT, IMPLEMENT LATER -> There are 32 integer registers, the register x0 is hardwired to zero
    PC Register holds the address of the current instruction
    
    Immediate values are always sign extended, except for some CSR instructions
    
RV64I DIFFERENCES:
    
    XLEN = 64
    W-suffixed instructions operate on lower 32 bits and produce 32 bit signed values sign-extended to 64 bit registers
    SLLIW, SRLIW, and SRAIW encodings with imm[5] = 0 are reserved.
    
]#

#[

TODO:

    Add sign-extension function? (for lines with <---)
    Move variables to inner scopes?
  
]#
